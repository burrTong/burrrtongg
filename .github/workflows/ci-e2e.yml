name: CI - build & e2e

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch: {}

jobs:
  build-backend:
    runs-on: ubuntu-latest
    env:
      POSTGRES_DB: ecommerce
      POSTGRES_USER: myuser
      POSTGRES_PASSWORD: mypass
      POSTGRES_PORT: '5432'
      SPRING_DATASOURCE_URL: jdbc:postgresql://localhost:5432/ecommerce
      SPRING_DATASOURCE_USERNAME: myuser
      SPRING_DATASOURCE_PASSWORD: mypass
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_DB: ecommerce
          POSTGRES_USER: myuser
          POSTGRES_PASSWORD: mypass
        ports: ['5432:5432']
        options: >-
          --health-cmd="pg_isready -U ${POSTGRES_USER}" --health-interval=10s --health-timeout=5s --health-retries=5
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '21'

      - name: Install postgres client for healthcheck
        run: |
          sudo apt-get update && sudo apt-get install -y postgresql-client

      - name: Wait for Postgres service
        run: |
          echo "Waiting for postgres to accept connections"
          for i in $(seq 1 30); do
            if pg_isready -h localhost -p ${POSTGRES_PORT} -U ${POSTGRES_USER}; then
              echo "postgres is ready"; break
            fi
            echo "waiting for postgres... ($i)"; sleep 2
          done

      - name: Grant execute permission for backend/gradlew
        run: |
          echo "Fixing gradlew permission in backend/"
          chmod +x ./backend/gradlew || true
          ls -l ./backend/gradlew || true

      - name: Build backend (Gradle)
        working-directory: ./backend
        run: |
          echo "Fixing gradlew permission in backend/ (again)"
          chmod +x ./gradlew || true
          ls -l ./gradlew || true
          ./gradlew clean build --no-daemon --stacktrace

  build-and-e2e:
    needs: build-backend
    runs-on: ubuntu-latest
    env:
      # keep compose project name stable so volume names are predictable
      COMPOSE_PROJECT_NAME: demo-repository
    # Provide defaults but allow overriding via repository Secrets
    env:
      POSTGRES_DB: ${{ secrets.POSTGRES_DB || 'demo_db' }}
      POSTGRES_USER: ${{ secrets.POSTGRES_USER || 'demo_user' }}
      POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD || 'demo_pass' }}
      POSTGRES_PORT: ${{ secrets.POSTGRES_PORT || '5432' }}
      BACKEND_APP_PORT: ${{ secrets.BACKEND_APP_PORT || '8080' }}
      FRONTEND_APP_PORT: ${{ secrets.FRONTEND_APP_PORT || '5173' }}
      PGADMIN_EXTERNAL_PORT: ${{ secrets.PGADMIN_EXTERNAL_PORT || '5050' }}
      PGADMIN_INTERNAL_PORT: ${{ secrets.PGADMIN_INTERNAL_PORT || '80' }}
      PGADMIN_DEFAULT_PASSWORD: ${{ secrets.PGADMIN_DEFAULT_PASSWORD || 'pgadmin' }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Log into Docker registry (optional)
        if: false
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Use repository .env if present (otherwise create from secrets/defaults)
        run: |
          if [ -f .env ]; then
            echo "Found repository .env — using it"
            echo "--- .env contents ---"
            sed -n '1,200p' .env
          else
            echo "No repository .env found — creating .env from secrets/defaults"
            cat > .env <<EOF
POSTGRES_DB=${POSTGRES_DB}
POSTGRES_USER=${POSTGRES_USER}
POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
POSTGRES_PORT=${POSTGRES_PORT}
BACKEND_APP_PORT=${BACKEND_APP_PORT}
FRONTEND_APP_PORT=${FRONTEND_APP_PORT}
PGADMIN_EXTERNAL_PORT=${PGADMIN_EXTERNAL_PORT}
PGADMIN_INTERNAL_PORT=${PGADMIN_INTERNAL_PORT}
PGADMIN_DEFAULT_PASSWORD=${PGADMIN_DEFAULT_PASSWORD}
EOF
          fi

      - name: Build and start services with docker-compose
        run: |
          docker compose build --parallel
          # ensure a clean postgres volume so /docker-entrypoint-initdb.d scripts run
          docker compose down -v || true

          # create uploads volume and copy repository images into it (so app can serve them)
          docker volume create ${COMPOSE_PROJECT_NAME}_uploads_data || true
          # use a temporary container to copy files from repo to the named volume
          if [ -d ./docker/uploads/images ] && [ "$(ls -A ./docker/uploads/images)" ]; then
            tmpc=$(docker create -v ${COMPOSE_PROJECT_NAME}_uploads_data:/uploads alpine:3.18 true)
            docker cp ./docker/uploads/images/. "$tmpc:/uploads"
            docker rm -v $tmpc || true
          else
            echo "No images found at ./docker/uploads/images to populate uploads volume"
          fi

          # bring up db (fresh volume) so init.sql executes
          docker compose up -d db
          # wait for Postgres to be ready from inside the db container
          for i in $(seq 1 60); do
            if docker compose exec -T db pg_isready -q; then
              echo "postgres is ready"; break
            fi
            echo "waiting for postgres... ($i)"; sleep 1
          done
          # start app and frontend once db is ready
          docker compose up -d app frontend

      - name: Verify DB initialized (products count)
        run: |
          echo "Checking products count in DB"
          # Use a temporary one-off container to run psql against the db service
          docker run --rm --network host postgres:15 bash -c "until pg_isready -h db -p ${POSTGRES_PORT} -U ${POSTGRES_USER}; do sleep 1; done; PGPASSWORD=${POSTGRES_PASSWORD} psql -h db -U ${POSTGRES_USER} -d ${POSTGRES_DB} -c \"SELECT count(*) FROM products;\""

      - name: Wait for backend to be healthy
        run: |
          echo "Waiting for backend on http://localhost:${BACKEND_APP_PORT}/actuator/health or /api/health"
          for i in $(seq 1 60); do
            if curl -sSf "http://localhost:${BACKEND_APP_PORT}/actuator/health" >/dev/null 2>&1 || curl -sSf "http://localhost:${BACKEND_APP_PORT}/api/health" >/dev/null 2>&1 || curl -sSf "http://localhost:${BACKEND_APP_PORT}/" >/dev/null 2>&1; then
              echo "backend is up"; exit 0
            fi
            echo "waiting for backend... ($i)"; sleep 1
          done
          echo "backend did not become ready in time"; exit 1

      - name: Run Cypress E2E tests (on runner)
        working-directory: frontend/burrtong
        env:
          CI: true
        run: |
          npm ci
          # run cypress; pass baseUrl and backend URL using shell-expanded vars
          npx cypress run --config baseUrl=http://localhost:${FRONTEND_APP_PORT} --env BACKEND_URL=http://localhost:${BACKEND_APP_PORT} || true

      - name: Upload Cypress artifacts (screenshots / videos)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: cypress-artifacts
          path: |
            frontend/burrtong/cypress/videos
            frontend/burrtong/cypress/screenshots
            frontend/burrtong/cypress/results
            frontend/burrtong/cypress/report
            frontend/burrtong/cypress/videos/**

      - name: Tear down docker-compose
        if: always()
        run: |
          docker compose down -v
